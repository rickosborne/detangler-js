<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>detangler game by Rick Osborne</title>
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/>
  <!--
  Hello there, View-Sourcerers!
  This was coded over a few hours on Nov 22, 2024.
  It's probably quite buggy, but It Works For Me.
  The inspiration was from Planarity by Jason Davies: https://www.jasondavies.com/planarity/
  However, I didn't look at the code there, just the concept.
  All the code here is my own, modulo a few bits of copypasta from SO and MDN.
  The license for this code is Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International: https://creativecommons.org/licenses/by-nc-sa/4.0/
  -->
  <style>
    * {
      border: none;
      font-size: 100%;
      list-style: none;
      margin: 0;
      overflow: hidden;
      overscroll-behavior: none;
      padding: 0;
      text-decoration: none;
      text-indent: 0;
    }

    html, body {
      background-color: black;
    }

    html, body, canvas {
      height: 100%;
      left: 0;
      overflow: hidden;
      position: absolute;
      top: 0;
      width: 100%;
    }
  </style>
  <script>
    /**
     * @typedef Orientation
     * @type {0|1|2}
     */

    /**
     * Helper class to calculate line segment intersections.
     * The algorithm here is based heavily on:
     * https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/
     */
    class Intersect {
      static CLOCKWISE = 1;
      static COLLINEAR = 0;
      static COUNTERCLOCKWISE = 2;

      /**
       * When two points (p and r) are collinear, is a third (q) between them?
       * @param {Point} p
       * @param {Point} q
       * @param {Point} r
       * @returns {boolean}
       */
      static onSegment(p, q, r) {
        return (q.x <= Math.max(p.x, r.x)) &&
          (q.x >= Math.min(p.x, r.x)) &&
          (q.y <= Math.max(p.y, r.y)) &&
          (q.y >= Math.min(p.y, r.y));
      }

      /**
       * For the three given points, if they are made into an angle,
       * do they point clockwise or counter-clockwise?
       * @param {Point} p
       * @param {Point} q
       * @param {Point} r
       * @returns {Orientation}
       */
      static orientation(p, q, r) {
        const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        if (val === 0) {
          return Intersect.COLLINEAR;
        }
        if (val > 0) {
          return Intersect.CLOCKWISE;
        }
        return Intersect.COUNTERCLOCKWISE;
      }

      /**
       * Given four points, each pair of which (a+b and c+d) is a line segment,
       * do those segments intersect?
       * @param {Point} a
       * @param {Point} b
       * @param {Point} c
       * @param {Point} d
       * @returns {boolean}
       */
      static points(a, b, c, d) {
        if (a.equals(c) || a.equals(d) || b.equals(c) || b.equals(d)) {
          return true;
        }
        const o1 = Intersect.orientation(a, b, c);
        const o2 = Intersect.orientation(a, b, d);
        const o3 = Intersect.orientation(c, d, a);
        const o4 = Intersect.orientation(c, d, b);
        if (o1 !== o2 && o3 !== o4) {
          return true;
        }
        if (o1 === Intersect.COLLINEAR && Intersect.onSegment(a, c, b)) {
          return true;
        }
        if (o2 === Intersect.COLLINEAR && Intersect.onSegment(a, d, b)) {
          return true;
        }
        if (o3 === Intersect.COLLINEAR && Intersect.onSegment(c, a, d)) {
          return true;
        }
        // noinspection RedundantIfStatementJS
        if (o4 === Intersect.COLLINEAR && Intersect.onSegment(c, b, d)) {
          return true;
        }
        return false;
      }
    }

    /**
     * Plain-old JS object for a rectangle.  Used for bounding boxes.
     */
    class Rectangle {
      /** @type {number} */
      height;
      /** @type {number} */
      width;
      /** @type {number} */
      x;
      /** @type {number} */
      y;

      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
    }

    /**
     * An (x,y) pair of coordinates, where the values have been rounded to the
     * nearest integer, to make comparisons easier.
     */
    class Point {
      /** @type {number} */
      x;
      /** @type {number} */
      y;

      /**
       * Don't use this directly â€” use {@link atXY} instead.
       * @param {number} x
       * @param {number} y
       */
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }

      /**
       * @param {number} x
       * @param {number} y
       * @returns {Point}
       */
      static atXY(x, y) {
        const roundX = Math.round(x);
        const roundY = Math.round(y);
        return new Point(roundX, roundY);
      }

      /**
       * Given another Point, are they the same?
       * @param {Point} other
       * @returns {boolean}
       */
      equals(other) {
        return other === this || ((other instanceof Point && other.x === this.x && other.y === this.y));
      }
    }

    /**
     * A line segment connecting two points.  Note that the {@code high}
     * and {@code low} here are indexes into an array of points â€” point IDs
     * instead of objects.  Because we know we're not going to have a more
     * than a few dozen of these, we keep a static set of them, and reuse
     * them on future calls.
     */
    class Edge {
      /** @type {Record<string,Edge>} */
      static #instances = {};
      /** @type {number} */
      high;
      /** @type {number} */
      low;

      /**
       * Don't call this directly.  Use {@link between} instead.
       * @param {number} low
       * @param {number} high
       */
      constructor(low, high) {
        this.low = low;
        this.high = high;
      }

      /**
       * @param {number} a
       * @param {number} b
       * @returns {Edge}
       */
      static between(a, b) {
        const low = Math.min(a, b);
        const high = Math.max(a, b);
        const str = [low, high].join("-");
        let instance = Edge.#instances[str];
        if (instance == null) {
          instance = new Edge(low, high);
          Edge.#instances[str] = instance;
        }
        return instance;
      }
    }

    /**
     * Helper for generating lists in the form {@code [0...n]}.
     */
    class IntList {
      /**
       * @param {number} size
       * @returns {number[]}
       */
      static ofSize(size) {
        /** @type {number[]} */
        const list = new Array(size);
        for (let i = 0; i < size; i++) {
          list[i] = i;
        }
        return list;
      }
    }

    /**
     * Model for a planar graph, with a set of points (nodes)
     * and edges between them.  Helps calculate intersections
     * between its edges.
     */
    class Tangle {
      /** @type {IntersectionTracker} */
      #intersectionTracker;
      /** @type {Edge[]} */
      edges;
      /** @type {Point[]} */
      points;

      /**
       * Don't call this directly â€” use {@link SplitFaceStrategy} instead.
       * @param {Point[]} points
       * @param {Edge[]} edges
       */
      constructor(points, edges) {
        this.points = points;
        this.edges = edges;

        /**
         * The real work horse behind all the intersection management.
         * Tries really hard to keep intersection-checking to something
         * close to O(n) instead of O(n^2).
         */
        class IntersectionTracker {
          /** @type {number} */
          #edgeCount;
          /** @type {number} */
          #intersecting = 0;
          /** @type {boolean[][]} */
          #intersects;

          /**
           * @param edgeCount
           */
          constructor(edgeCount) {
            this.#edgeCount = edgeCount;
            this.#intersects = IntList.ofSize(edgeCount)
              .map(() => IntList.ofSize(edgeCount).map(() => false));
            for (let i = 0; i < edgeCount; i++) {
              for (let j = i + 1; j < edgeCount; j++) {
                this.setFor(i, j);
              }
            }
          }

          /**
           * @param {number} edgeIndex
           * @returns {number}
           */
          intersectionsForEdge(edgeIndex) {
            let count = 0;
            for (let i = 0; i < edgeIndex; i++) {
              if (this.#intersects[i][edgeIndex]) {
                count++;
              }
            }
            for (let i = edgeIndex + 1; i < this.#edgeCount; i++) {
              if (this.#intersects[edgeIndex][i]) {
                count++;
              }
            }
            return count;
          }

          /**
           * @returns {boolean}
           */
          isDetangled() {
            return this.#intersecting === 0;
          }

          /**
           * @param {number} pointIndex
           * @returns {void}
           */
          recalculatePoint(pointIndex) {
            for (let edgeIndex = 0; edgeIndex < this.#edgeCount; edgeIndex++) {
              const edge = edges[edgeIndex];
              if (edge.low === pointIndex || edge.high === pointIndex) {
                for (let j = 0; j < edgeIndex; j++) {
                  this.setFor(j, edgeIndex);
                }
                for (let j = edgeIndex + 1; j < this.#edgeCount; j++) {
                  this.setFor(edgeIndex, j);
                }
              }
            }
          }

          /**
           * @param {number} low
           * @param {number} high
           * @param {boolean} after
           * @returns {void}
           */
          setAt(low, high, after) {
            const before = this.#intersects[low][high];
            if (before === after) {
              return;
            }
            this.#intersecting += after ? 1 : -1;
            this.#intersects[low][high] = after;
          }

          /**
           * @param {number} low
           * @param {number} high
           * @returns {void}
           */
          setFor(low, high) {
            const a = edges[low];
            const b = edges[high];
            if (a == null || b == null) {
              debugger;
            }
            if (a.low === b.low || a.low === b.high || a.high === b.low || a.high === b.high) {
              return;
            }
            const doesIntersect = Intersect.points(points[a.low], points[a.high], points[b.low], points[b.high]);
            this.setAt(low, high, doesIntersect);
          }
        }

        this.#intersectionTracker = new IntersectionTracker(edges.length);
      }

      /**
       * Calculate max and min X and Y coordinates, so the points can be resized.
       * @returns {Rectangle}
       */
      bounds() {
        const first = this.points[0];
        let minX = first.x;
        let maxX = first.x;
        let minY = first.y;
        let maxY = first.y;
        for (const point of this.points) {
          const x = point.x;
          const y = point.y;
          if (x < minX) minX = x;
          else if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          else if (y > maxY) maxY = y;
        }
        return new Rectangle(minX, minY, maxX - minX, maxY - minY);
      }

      /**
       * @param {number} edgeIndex
       * @returns {number}
       */
      intersectionsForEdge(edgeIndex) {
        return this.#intersectionTracker.intersectionsForEdge(edgeIndex);
      }

      /**
       * @returns {boolean}
       */
      isDetangled() {
        return this.#intersectionTracker.isDetangled();
      }

      /**
       * @param {number} pointIndex
       * @param {Point} before
       * @param {Point} after
       */
      onPointMoved(pointIndex, before, after) {
        if (before.equals(after)) {
          return;
        }
        this.points[pointIndex] = after;
        this.#intersectionTracker.recalculatePoint(pointIndex);
      }

      /**
       * Given a new box to fit within, scale the current graph to fit it.
       * @param {Rectangle} box
       * @returns {Tangle}
       */
      scale(box) {
        const original = this.bounds();
        const originalWidth = Math.max(1, original.width);
        const originalHeight = Math.max(1, original.height);
        const originalX = Math.round(original.x);
        const originalY = Math.round(original.y);
        const ratioX = box.width / originalWidth;
        const ratioY = box.height / originalHeight;
        const newX = box.x;
        const newY = box.y;
        const newPoints = this.points.map((point) => Point.atXY(
          ((point.x - originalX) * ratioX) + newX,
          ((point.y - originalY) * ratioY) + newY,
        ));
        return new Tangle(newPoints, this.edges);
      }
    }

    /**
     * Helper to make {@link Math.random} calls easier to read.
     * It uses a super simple Linear Congruential Generator:
     * https://en.wikipedia.org/wiki/Linear_congruential_generator
     */
    class Rand {
      /** @type {Rand} */
      static instance = new Rand();
      // Delphi/Turbo Pascal's seeds.  Because ðŸ¥° that's basically where
      // it all started for me.
      #a = 134775813;
      #c = 1;
      #m = 2 ** 31;
      /** @type {number} */
      #state;

      constructor(seed = Date.now()) {
        this.#state = seed;
      }

      /**
       * Return a random integer in the range {@code (-n...n)}.
       * @param {number} radius
       * @returns {number}
       */
      static around(radius) {
        const sign = Rand.instance.int() % 2 === 0 ? -1 : 1;
        return Rand.instance.range(0, radius) * sign;
      }

      /**
       * Return an integer in the range {@code [0...n)}.
       * Uses {@link Math.trunc} instead of {@link Math.floor} so
       * it will always round toward 0.  Generally used to get
       * a random item in an array.
       * @param {number} length
       * @returns {number}
       */
      static index(length) {
        return Rand.instance.range(0, length);
      }

      /** @returns {number} */
      int() {
        this.#state = (this.#a * this.#state + this.#c) % this.#m;
        return this.#state;
      }

      /**
       * @param {number} low
       * @param {number} high
       * @returns {number} In the range [low...high)
       */
      range(low, high) {
        const width = high - low;
        const float = this.int() / this.#m;
        return low + Math.trunc(float * width);
      }
    }

    /**
     * Fancy wrapper around an array of point indices.  That is,
     * {@code [0, 1, 3, 5]} is a polygon which goes through points
     * 0, 1, 3, 5, and then back around to 0.
     * If there are enough points, can be split into two smaller faces.
     */
    class Face {
      /** @type {number[]} */
      indices;

      /**
       * @param {number[]} indices
       */
      constructor(indices) {
        this.indices = indices;
      }

      /**
       * @param {number} size
       * @returns {Face}
       */
      static ofSize(size) {
        return new Face(IntList.ofSize(size));
      }

      /**
       * @returns {boolean}
       */
      canSplit() {
        return this.indices.length > 3;
      }

      /**
       * Split this Face into two smaller Faces by slicing between two
       * random non-adjacent points.
       * @returns {[Face,Face]}
       */
      randomSplit() {
        const count = this.indices.length;
        const leftIndex = Rand.index(count);
        // We need the points to not be adjacent, so that eliminates
        // (1) the point itself, and its (2) neighbors.
        const rightOffset = Rand.index(count - 3);
        const rightIndex = (leftIndex + 2 + rightOffset) % count;
        const low = Math.min(leftIndex, rightIndex);
        const high = Math.max(leftIndex, rightIndex);
        return this.split(low, high);
      }

      /**
       * Split the current Face into two smaller ones by slicing between
       * the given points.  The math here assumes {@link low} and {@link high}
       * are in ascending numerical order.
       * Visually:
       * @example
       * Imagine the polygon described by these points:
       *     0---1
       *     |    \
       *     |     3
       *     |    /
       *     5---4
       * In array form, this would look like:
       *     [ 0, 1, 3, 4, 5 ]
       * If we wanted to slice along between the points (1, 4), this would
       * divide this array into two logical parts:
       *     [ 0, 1, 3, 4, 5 ]
       *     -----|=====|-----
       * That is, numbers with `-` beneath them become one new face, while `=`
       * numbers become the other:
       *     [ 1, 3, 4 ] and [ 0, 1, 4, 5 ]
       * In the code below, the `=` numbers are the "inside", while the `-`
       * numbers are the "outside".
       * @param {number} low
       * @param {number} high
       * @returns {[Face,Face]}
       */
      split(low, high) {
        // The "inner" slice is easy, as it just throws out the points outside the range.
        const inner = this.indices.slice(low, high + 1);
        // The "outside" is the two remainder halves conjoined.
        const outer = [
          ...this.indices.slice(0, low + 1),
          ...this.indices.slice(high),
        ];
        return [
          new Face(inner),
          new Face(outer),
        ];
      }
    }

    /**
     * @see https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     */
    class FisherYatesShuffle {
      /**
       * Shuffles an array in-place.
       * @template {any} T
       * @param {T[]} list
       * @returns {void}
       */
      static inPlace(list) {
        for (let i = list.length - 1; i > 0; i--) {
          const targetIndex = Rand.index(i);
          const targetPoint = list[targetIndex];
          list[targetIndex] = list[i];
          list[i] = targetPoint;
        }
      }
    }

    /**
     * When starting a new Tangle, it can be confusing to use completely
     * random starting positions, as those have a decent chance of overlap.
     * Instead, we divide up the screen into roughly square-ish parts, at least
     * as many as we need, find their centers, fuzz those a bit, shuffle them,
     * and return them.  This produces a starting Tangle which is still chaotic,
     * but easier for players to quickly intuit.
     */
    class Grid {
      /**
       * @param {number} pointCount
       * @param {number} width
       * @param {number} height
       */
      static randomForPoints(pointCount, width, height) {
        const aspect = width / height;
        // aspect = cols / rows       -> cols = rows * aspect
        // pointCount = cols * rows   -> cols = pointCount / rows
        // -> rows * aspect = pointCount / rows
        // -> rows * rows = pointCount / aspect
        let minRows = Math.ceil(Math.sqrt(pointCount / aspect));
        const rows = minRows + 1;
        const cols = Math.ceil(pointCount / minRows) + 1;
        const rowHeight = Math.round(height / rows);
        const colWidth = Math.round(width / cols);
        const halfHeight = Math.round(rowHeight / 2);
        const halfWidth = Math.round(colWidth / 2);
        /** @type {Point[]} */
        const more = new Array(rows * cols);
        let nextPointIndex = 0;
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            more[nextPointIndex] = Point.atXY(
              col * colWidth + halfWidth + Rand.around(halfWidth * 0.8),
              row * rowHeight + halfHeight + Rand.around(halfHeight * 0.8),
            );
            nextPointIndex++;
          }
        }
        FisherYatesShuffle.inPlace(more);
        return more.slice(0, pointCount);
      }
    }

    /**
     * Cheap and easy way of generating a graph which is guaranteed to
     * be planar, and thus capable of being detangled.
     * 1. Start with a simple (convex) polygon of the given number of sides.
     * 2. Pick any two non-adjacent points on that polygon.
     * 3. Split the polygon along a new seam along those two points.
     * 4. For each of the two new polygons:
     *    a. If there are at least 3 points, put it into a list of polygons
     *       we can split in the future.
     *    b. Otherwise, put it into a list of triangles.
     * 5. From the list of splittable polygons, pick a random one and loop
     *    back up to Step 2.
     * 6. With the list of resulting triangles, generate a Set of their
     *    points and edges.
     * 7. Generate random starting positions for each point.
     */
    class SplitFaceStrategy {
      /**
       * @param {number} pointCount
       * @param {number} width
       * @param {number} height
       * @returns {Tangle}
       */
      static buildTangle(pointCount, width, height) {
        /** @type {Point[]} */
        const starts = Grid.randomForPoints(pointCount, width, height);
        const points = starts.slice(0, pointCount);
        const all = Face.ofSize(pointCount);
        /** @type {Face[]} */
        const splittable = [all];
        /** @type {Face[]} */
        const keep = [];
        const edgeCount = (pointCount * 2) - 2;
        for (let i = 0; i < edgeCount && splittable.length > 0; i++) {
          const index = Rand.index(splittable.length);
          const one = splittable.splice(index, 1)[0];
          const two = one.randomSplit();
          for (const face of two) {
            if (face.canSplit()) splittable.push(face);
            else keep.push(face);
          }
        }
        // There shouldn't be anything here, but just in case ...
        keep.push(...splittable);
        /** @type {Set<Edge>} */
        const edgeSet = new Set();
        for (const face of keep) {
          const count = face.indices.length;
          let previous = face.indices.at(-1);
          for (let i = 0; i < count; i++) {
            const next = face.indices[i];
            const edge = Edge.between(previous, next);
            edgeSet.add(edge);
            previous = next;
          }
        }
        const edges = Array.from(edgeSet)
          .sort((a, b) => a.low !== b.low ? (a.low - b.low) : (a.high - b.high));
        return new Tangle(points, edges);
      }
    }

    /**
     * Abstract model for a game of some size containing a tangled graph.
     * It's a little anemic because the game is simple.  With a more robust
     * game, this might have additional interaction logic, consistency checking,
     * etc.
     */
    class DetanglerGame {
      /** @type {number} */
      #height;
      /** @type {Tangle} */
      #tangle;
      /** @type {number} */
      #width;

      /**
       * @param {number} pointCount
       * @param {number} width
       * @param {number} height
       */
      constructor(pointCount, width, height) {
        this.#height = height;
        this.#width = width;
        this.#tangle = SplitFaceStrategy.buildTangle(pointCount, width, height);
      }

      /**
       * @returns {Edge[]}
       */
      get edges() {
        return this.#tangle.edges;
      }

      /**
       * @returns {Point[]}
       */
      get points() {
        return this.#tangle.points;
      }

      /**
       * @param {number} edgeIndex
       * @returns {number}
       */
      intersectionCountForEdge(edgeIndex) {
        return this.#tangle.intersectionsForEdge(edgeIndex);
      }

      /**
       * @returns {boolean}
       */
      isDetangled() {
        return this.#tangle.isDetangled();
      }

      /**
       * Tells the Tangle that a point moved, and it must invalidate and
       * recalculate the intersections for the related segments.
       * @param {number} pointIndex
       * @param {Point} before
       * @param {Point} after
       * @returns {void}
       */
      onPointMove(pointIndex, before, after) {
        this.#tangle.onPointMoved(pointIndex, before, after);
      }

      /**
       * Tells the tangle the game board size changed, and thus
       * the tangle should resize itself to fit.  This changes the
       * point coordinates, but not their intersections.
       * @param {number} width
       * @param {number} height
       * @returns {void}
       */
      onResize(width, height) {
        this.#width = width;
        this.#height = height;
        const margin = Math.round(Math.min(this.#width, this.#height) * 0.1);
        this.#tangle = this.#tangle.scale(new Rectangle(margin, margin, width - (2 * margin), height - (2 * margin)));
      }
    }

    class Interpolate {
      /**
       * @param {number} a
       * @param {number} b
       * @param {number} percent
       */
      static linearRound(a, b, percent) {
        if (a === b) {
          return a;
        }
        return a + Math.round((b - a) * percent);
      }
    }


    class Color {
      /** @type {number} */
      a;
      /** @type {number} */
      b;
      /** @type {number} */
      g;
      /** @type {string} */
      hex;
      /** @type {number} */
      r;

      constructor(r, g, b, a = 255, hex) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
        this.hex = hex ?? this.toHex();
      }

      /**
       * @param {string} hex
       * @returns {Color}
       */
      static fromHex(hex) {
        let int = parseInt(hex.replace(/^#/, ""), 16);
        const byte = () => {
          const rem = int % 256;
          int >>= 8;
          return rem;
        };
        let a = 255;
        if (hex.length >= 8) {
          a = byte();
        }
        const b = byte();
        const g = byte();
        const r = byte();
        return new Color(r, g, b, a, hex);
      }

      /**
       * @param {number} n
       * @returns {string}
       */
      static hexByte(n) {
        const hex = n.toString(16);
        return hex.length < 2 ? "0".concat(hex) : hex;
      }

      /**
       * @param {Color} other
       * @param {number} percent
       * @returns {Color}
       */
      combine(other, percent) {
        return new Color(
          Interpolate.linearRound(this.r, other.r, percent),
          Interpolate.linearRound(this.g, other.g, percent),
          Interpolate.linearRound(this.b, other.b, percent),
          Interpolate.linearRound(this.a, other.a, percent),
        );
      }

      /**
       * @param {number} brightness in the range [0...1]
       * @return {Color}
       */
      dim(brightness) {
        return new Color(
          Math.trunc(this.r * brightness),
          Math.trunc(this.g * brightness),
          Math.trunc(this.b * brightness),
          this.a,
        );
      }

      /**
       * @returns {string}
       */
      toHex() {
        if (this.hex == null) {
          const parts = [
            "#",
            Color.hexByte(this.r),
            Color.hexByte(this.g),
            Color.hexByte(this.b),
          ];
          if (this.a !== 255) {
            parts.push(Color.hexByte(this.a));
          }
          this.hex = parts.join("");
        }
        return this.hex;
      }
    }

    /**
     * A set of colors in which the game should be drawn.
     */
    class Theme {
      static DefaultGray = "#777777";
      static DefaultSilver = "#eeeeee";
      static Ace = new Theme("#5e1984", "#9e9e9e", "#3da542", Theme.DefaultSilver, "#ffffff");
      static Eight = new Theme("#fcf431", Theme.DefaultGray, Theme.DefaultSilver, "#9d59d2", "#ffffff");
      static Jack = new Theme("#bcc4c7", Theme.DefaultGray, Theme.DefaultSilver, "#a5fa5e", "#ffffff");
      static Joker = new Theme("#21b0fe", Theme.DefaultGray, "#fed700", "#fe218b", "#fed700");
      static King = new Theme("#fe941e", Theme.DefaultGray, "#ffff00", "#ff1e26", "#ffff00");
      static Nine = new Theme("#b57edc", Theme.DefaultGray, Theme.DefaultSilver, "#4a8122", "#ffffff");
      static Queen = new Theme("#a20161", "#fd9855", "#d42c00", "#ffffff", "#d161a2");
      static Seven = new Theme("#d70071", Theme.DefaultGray, "#0035aa", "#9c4e97", Theme.DefaultGray);
      static Ten = new Theme("#f6aab7", Theme.DefaultGray, Theme.DefaultSilver, "#55cdfd", "#ffffff");
      static All = [Theme.Ace, Theme.King, Theme.Queen, Theme.Jack, Theme.Ten, Theme.Nine, Theme.Eight, Theme.Seven, Theme.Joker];
      /** @type {Color} */
      edgeDefault;
      /** @type {Color} */
      edgeIntersected;
      /** @type {Color} */
      edgeTouched;
      /** @type {Color} */
      pointDefault;
      /** @type {Color} */
      pointTouched;

      constructor(edgeDefault, edgeIntersected, edgeTouched, pointDefault, pointTouched) {
        this.edgeDefault = Color.fromHex(edgeDefault);
        this.edgeIntersected = Color.fromHex(edgeIntersected);
        this.edgeTouched = Color.fromHex(edgeTouched);
        this.pointDefault = Color.fromHex(pointDefault);
        this.pointTouched = Color.fromHex(pointTouched);
      }

      /**
       * @returns {Theme}
       */
      static random() {
        const index = Rand.index(Theme.All.length);
        return Theme.All[index];
      }
    }

    /**
     * A model for both the drawing and interaction of the game.
     * This could likely be simplified a bit by extracting out some
     * concerns, like touch tracking.  But it's not too bad, and is
     * actually pretty easy to step through this way ... so :shrug:.
     */
    class DetanglerActor {
      /** @type {[HTMLCanvasElement, HTMLCanvasElement, HTMLCanvasElement, HTMLCanvasElement]} */
      #canvases;
      /** @type {Map<number,number>} */
      #coolingEdges;
      /** @type {Map<number,number>} */
      #coolingPoints;
      /** @type {function(MouseEvent):void} */
      #downListener;
      /** @type {[CanvasRenderingContext2D, CanvasRenderingContext2D, CanvasRenderingContext2D, CanvasRenderingContext2D]} */
      #draws;
      /** @type {number} */
      #drawCount = 0;
      /** @type {number|null} */
      #edgeWidth;
      /** @type {number|null} */
      #fadeStarted = null;
      /** @type {DetanglerGame} */
      #game;
      /** @type {boolean} */
      #gradients;
      /** @type {number} */
      #height;
      /** @type {number[]} */
      #lastStaticEdgeIndexes = [];
      /** @type {number[]} */
      #lastStaticPointIndexes = [];
      /** @type {function(MouseEvent):void} */
      #moveListener;
      /** @type {(function(number):void)[]} */
      #onAnimates = [];
      /** @type {function():void} */
      #onDetangled;
      /** @type {number} */
      #sizeDivisor;
      /** @type {number} */
      #startTime = Date.now();
      /** @type {Theme} */
      #theme;
      /** @type {function(TouchEvent):void} */
      #touchEndListener;
      /** @type {function(TouchEvent):void} */
      #touchMoveListener;
      /** @type {function(TouchEvent):void} */
      #touchStartListener;
      /** @type {number} */
      #touchedPoint = -1;
      /** @type {function(MouseEvent):void} */
      #upListener;
      /** @type {number} */
      #width;
      /** @type {boolean} */
      #willAnimate = false;

      /**
       * @param {number} pointCount
       * @param {number} sizeDivisor
       * @param {boolean} gradients
       * @param {[HTMLCanvasElement, HTMLCanvasElement, HTMLCanvasElement, HTMLCanvasElement]} canvases
       * @param {function():void} onDetangled
       */
      constructor(pointCount, sizeDivisor, gradients, canvases, onDetangled) {
        // Burn through some random numbers, so subsequent games don't always start the same.
        for (let i = 0; i < pointCount; i++) Rand.instance.int();
        this.#canvases = canvases;
        this.#width = canvases[0].width;
        this.#height = canvases[0].height;
        this.#sizeDivisor = sizeDivisor;
        this.#edgeWidth = null;
        this.#gradients = gradients;
        this.#coolingEdges = new Map();
        this.#coolingPoints = new Map();
        this.#game = new DetanglerGame(pointCount, this.#width, this.#height);
        this.#draws = canvases.map((canvas, index) => canvas.getContext("2d", {
          alpha: index > 0,
          antialias: true,
        }));
        this.#onDetangled = onDetangled;
        this.#theme = Theme.random();
        const pixel = window.devicePixelRatio;
        // Save these, so they can be `removeEventListener`-ed later.
        // But also: you need to translate from page (px) coordinates to their
        // ratio-ed (sub-px) counterpart.
        this.#downListener = (event) => this.onDown(event.offsetX * pixel, event.offsetY * pixel);
        this.#moveListener = (event) => this.onMove(event.offsetX * pixel, event.offsetY * pixel);
        this.#upListener = (event) => this.onUp(event.offsetX * pixel, event.offsetY * pixel);
        /**
         * @param {TouchEvent} event
         * @param {function(number,number):void} callback
         */
        const withOneTouch = (event, callback) => {
          /** @type {Touch|undefined} */
          let touch = undefined;
          if (event.changedTouches?.length === 1) {
            touch = event.changedTouches[0];
          } else if (event.touches?.length === 1) {
            touch = event.touches.item(0);
          }
          if (touch != null) {
            callback(touch.clientX * pixel, touch.clientY * pixel);
            event.preventDefault();
          }
        };
        const topCanvas = canvases[canvases.length - 1];
        // Yes, this is a total hack and is probably horrible for accessibility.  Sigh.
        this.#touchEndListener = (event) => withOneTouch(event, (x, y) => this.onUp(x, y));
        this.#touchMoveListener = (event) => withOneTouch(event, (x, y) => this.onMove(x, y));
        this.#touchStartListener = (event) => withOneTouch(event, (x, y) => this.onDown(x, y));
        topCanvas.addEventListener("mousedown", this.#downListener);
        topCanvas.addEventListener("mouseup", this.#upListener);
        topCanvas.addEventListener("touchstart", this.#touchStartListener);
        topCanvas.addEventListener("touchend", this.#touchEndListener);
        // To save battery on mobile devices, redraw only on demand,
        // not on a schedule.
        this.animate("constructor");
      }

      get edgeWidth() {
        this.#edgeWidth ??= Math.round(Math.min(this.#canvases[0].clientWidth, this.#canvases[0].clientHeight) / this.#sizeDivisor);
        return this.#edgeWidth;
      }

      /**
       * Request a redraw.
       * @param {string} caller
       * @param {function(number):void} [timestampCallback]
       * @returns {void}
       */
      animate(caller, timestampCallback) {
        if (timestampCallback != null) {
          this.#onAnimates.push(timestampCallback);
        }
        if (this.#willAnimate) {
          return;
        }
        this.#willAnimate = true;
        // console.log(`RAF: ${caller}`);
        requestAnimationFrame((timestamp) => {
          this.#willAnimate = false;
          this.draw(timestamp);
        });
      }

      coolEdge(edgeIndex) {
        this.#coolingEdges.delete(edgeIndex);
      }

      coolPoint(pointIndex) {
        this.#coolingPoints.delete(pointIndex);
      }

      /**
       * The actual drawing logic.
       * @param {number} timestamp
       */
      draw(timestamp) {
        if (this.#onAnimates.length > 0) {
          // console.log(`onAnimate: ${this.#onAnimates.length}`);
          this.#onAnimates.forEach((callback) => {
            // console.log(callback.toString());
            callback(timestamp);
          });
          this.#onAnimates = [];
        }
        this.#drawCount++;
        const [dSE, dDE, dSN, dDN] = this.#draws;
        /** @param {CanvasRenderingContext2D} d */
        const clearDraw = (d) => {
          d.clearRect(0, 0, this.#width, this.#height);
        };
        clearDraw(dDE);
        clearDraw(dDN);
        const edges = this.#game.edges;
        const points = this.#game.points;
        const edgeWidth = this.edgeWidth;
        const pointRadius = edgeWidth * 2;
        const coolTimeMs = 2_000;
        let {edgeDefault, edgeIntersected, edgeTouched, pointTouched, pointDefault} = this.#theme;
        let queueAnotherDraw = false;
        if (this.#fadeStarted !== null) {
          const elapsed = timestamp - this.#fadeStarted;
          const remain = Math.max(0, coolTimeMs - elapsed);
          const intensity = remain / coolTimeMs;
          edgeDefault = edgeDefault.dim(intensity);
          edgeIntersected = edgeIntersected.dim(intensity);
          edgeTouched = edgeTouched.dim(intensity);
          pointTouched = pointTouched.dim(intensity);
          pointDefault = pointDefault.dim(intensity);
          if (remain > 0) {
            queueAnotherDraw = true;
          } else {
            const durationSecs = Math.round((Date.now() - this.#startTime) / 1000);
            if (durationSecs > 0) {
              const fps = this.#drawCount / durationSecs;
              console.log(`Finished ${points.length} after ${durationSecs}s.  Drew ${this.#drawCount} frames for ${fps.toPrecision(3)}fps.`);
            }
            this.#onDetangled();
            return;
          }
        }
        const twoPi = Math.PI * 2;
        dSE.lineWidth = edgeWidth;
        dDE.lineWidth = edgeWidth;
        /** @type {number[]} */
        const touchedIndexes = [];
        /** @type {number[]} */
        const coolingIndexes = [];
        /** @type {number[]} */
        const idleIndexes = [];
        for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {
          const edge = edges[edgeIndex];
          const touched = edge.low === this.#touchedPoint || edge.high === this.#touchedPoint;
          if (touched) {
            touchedIndexes.push(edgeIndex);
            continue;
          }
          const temp = this.#coolingEdges.get(edgeIndex);
          if (temp != null) {
            const remainPercent = (coolTimeMs - (timestamp - temp)) / coolTimeMs;
            if (remainPercent > 0) {
              coolingIndexes.push(edgeIndex);
              continue;
            } else {
              this.coolEdge(edgeIndex);
            }
          }
          idleIndexes.push(edgeIndex);
        }
        const idleSame = (idleIndexes.length === this.#lastStaticEdgeIndexes.length) && idleIndexes.every((v, n) => v === this.#lastStaticEdgeIndexes[n]);
        const drawnEdgeList = [coolingIndexes, touchedIndexes];
        if (!idleSame || this.#fadeStarted || (coolingIndexes.length === 0 && touchedIndexes.length === 0)) {
          drawnEdgeList.unshift(idleIndexes);
          clearDraw(dSE);
        }
        this.#lastStaticEdgeIndexes = idleIndexes;
        for (const edgeList of drawnEdgeList) {
          for (const edgeIndex of edgeList) {
            const edge = edges[edgeIndex];
            const touched = edge.low === this.#touchedPoint || edge.high === this.#touchedPoint;
            const p1 = points[edge.low];
            const p2 = points[edge.high];
            const intersected = this.#game.intersectionCountForEdge(edgeIndex) > 0;
            let color = touched ? edgeTouched : intersected ? edgeIntersected : edgeDefault;
            if (!touched) {
              const temp = this.#coolingEdges.get(edgeIndex);
              if (temp != null) {
                const remainPercent = (coolTimeMs - (timestamp - temp)) / coolTimeMs;
                color = color.combine(edgeTouched, remainPercent);
              }
            }
            const d = edgeList === idleIndexes ? dSE : dDE;
            d.beginPath();
            d.moveTo(p1.x, p1.y);
            d.lineTo(p2.x, p2.y);
            d.lineWidth = edgeWidth;
            if (this.#gradients) {
              const darker = color.dim(0.75);
              const gradient = d.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
              gradient.addColorStop(0, darker.hex);
              gradient.addColorStop(0.25, color.hex);
              gradient.addColorStop(0.75, color.hex);
              gradient.addColorStop(1, darker.hex);
              d.strokeStyle = gradient;
            } else {
              d.strokeStyle = color.hex;
            }
            d.stroke();
          }
        }
        /** @type {number[]} */
        const idlePoints = [];
        /** @type {number[]} */
        const dynamicPoints = [];
        for (let pointIndex = 0; pointIndex < points.length; pointIndex++) {
          const touched = pointIndex === this.#touchedPoint;
          const temp = this.#coolingPoints.get(pointIndex);
          let dynamic = touched;
          if (temp != null) {
            const remainPercent = (coolTimeMs - (timestamp - temp)) / coolTimeMs;
            if (remainPercent <= 0) {
              this.coolPoint(pointIndex);
            } else {
              dynamic = true;
            }
          }
          if (dynamic) {
            dynamicPoints.push(pointIndex);
          } else {
            idlePoints.push(pointIndex);
          }
        }
        const drawnPointsLists = [dynamicPoints];
        const staticPointsSame = idlePoints.length === this.#lastStaticPointIndexes.length && idlePoints.every((i, n) => this.#lastStaticPointIndexes[n] === i);
        if (!staticPointsSame || this.#fadeStarted || dynamicPoints.length === 0) {
          clearDraw(dSN);
          drawnPointsLists.unshift(idlePoints);
        }
        this.#lastStaticPointIndexes = idlePoints;
        dDN.strokeStyle = "none";
        dSN.strokeStyle = "none";
        for (const pointsList of drawnPointsLists) {
          for (const pointIndex of pointsList) {
            const point = points[pointIndex];
            const touched = pointIndex === this.#touchedPoint;
            const baseColor = touched ? pointTouched : pointDefault;
            let color = baseColor;
            const temp = this.#coolingPoints.get(pointIndex);
            if (temp != null) {
              const remainPercent = (coolTimeMs - (timestamp - temp)) / coolTimeMs;
              color = baseColor.combine(pointTouched, remainPercent);
            }
            const d = pointsList === idlePoints ? dSN : dDN;
            d.fillStyle = color.hex;
            d.beginPath();
            d.arc(point.x, point.y, pointRadius, 0, twoPi);
            d.fill();
            d.fillStyle = "black";
            d.beginPath();
            d.arc(point.x, point.y, edgeWidth, 0, twoPi);
            d.fill();
          }
          if (this.#coolingPoints.size > 0 || this.#coolingEdges.size > 0) {
            queueAnotherDraw = true;
          }
          if (queueAnotherDraw) {
            this.animate("draw");
          }
        }
      }

      /**
       * @returns {[number,number,number,number]}
       */
      getCanvasSize() {
        const pixels = window.devicePixelRatio;
        const width = window.innerWidth * pixels;
        const height = window.innerHeight * pixels;
        return [width, height, window.innerWidth, window.innerHeight];
      }

      /**
       * @param {number} x
       * @param {number} y
       * @returns {void}
       */
      onDown(x, y) {
        let closestDistance = -1;
        let closestIndex = -1;
        const points = this.#game.points;
        const pointRadius = this.edgeWidth * 5;  // technically 2, but we fudge a bit
        for (let i = 0; i < points.length; i++) {
          const point = points[i];
          const dx = x - point.x;
          const dy = y - point.y;
          const distance = Math.round(Math.sqrt(dx * dx + dy * dy));
          if (distance <= pointRadius && (closestDistance === -1 || closestDistance > distance)) {
            closestDistance = distance;
            closestIndex = i;
          }
        }
        if (closestIndex >= 0) {
          if (this.#touchedPoint < 0) {
            const topCanvas = this.#canvases[this.#canvases.length - 1];
            topCanvas.addEventListener("mousemove", this.#moveListener);
            topCanvas.addEventListener("touchmove", this.#touchMoveListener);
          }
          this.#touchedPoint = closestIndex;
          this.animate("onDown", (ts) => {
            this.warmNeighbors(closestIndex, ts);
          });
        }
      }

      /**
       * @param {number} x
       * @param {number} y
       * @returns {void}
       */
      onMove(x, y) {
        const touchedPoint = this.#touchedPoint;
        if (touchedPoint >= 0) {
          const point = this.#game.points[touchedPoint];
          const before = Point.atXY(point.x, point.y);
          const clampedX = Math.min(Math.max(this.edgeWidth, x), this.#width - this.edgeWidth - 1);
          const clampedY = Math.min(Math.max(this.edgeWidth, y), this.#height - this.edgeWidth - 1);
          const after = Point.atXY(clampedX, clampedY);
          if (!before.equals(after)) {
            this.#game.onPointMove(touchedPoint, before, after);
            this.animate("onMove", (ts) => {
              this.warmNeighbors(touchedPoint, ts);
            });
          }
        }
      }

      onResize() {
        const [newWidth, newHeight, pxWidth, pxHeight] = this.getCanvasSize();
        if (newWidth === this.#width && newHeight === this.#height) {
          return;
        }
        // console.log(`Resize: ${this.#width}x${this.#height} -> ${newWidth}x${newHeight}`);
        this.#canvases.forEach((canvas) => {
          canvas.width = newWidth;
          canvas.height = newHeight;
          canvas.style.width = `${pxWidth}px`;
          canvas.style.height = `${pxHeight}px`;
        });
        this.#width = newWidth;
        this.#height = newHeight;
        this.#game.onResize(newWidth, newHeight);
        this.#edgeWidth = null;
        this.animate("onResize");
      }

      /**
       * @param {number} _x
       * @param {number} _y
       * @returns {void}
       */
      onUp(_x, _y) {
        if (this.#touchedPoint >= 0) {
          this.#touchedPoint = -1;
          const detangled = this.#game.isDetangled();
          const moveOnly = !detangled;
          this.pauseInput(moveOnly);
          if (detangled) {
            this.#coolingEdges.clear();
            this.#coolingPoints.clear();
          }
          const startFade = detangled ? ((fadeStarted) => {
            this.#fadeStarted = fadeStarted;
          }) : undefined;
          this.animate("onUp", startFade);
        }
      }

      /**
       * @param {boolean} [moveOnly]
       * @returns {void}
       */
      pauseInput(moveOnly = false) {
        const topCanvas = this.#canvases[this.#canvases.length - 1];
        topCanvas.removeEventListener("mousemove", this.#moveListener);
        topCanvas.removeEventListener("touchmove", this.#touchMoveListener);
        if (!moveOnly) {
          topCanvas.removeEventListener("mousedown", this.#downListener);
          topCanvas.removeEventListener("mouseup", this.#upListener);
          topCanvas.removeEventListener("touchstart", this.#touchStartListener);
          topCanvas.removeEventListener("touchend", this.#touchEndListener);
        }
      }

      warmEdge(edgeIndex, timestamp) {
        this.#coolingEdges.set(edgeIndex, timestamp);
      }

      /**
       * @param {number} pointIndex
       * @param {number} timestamp
       * @returns {void}
       */
      warmNeighbors(pointIndex, timestamp) {
        if (this.#fadeStarted != null) return;
        const edges = this.#game.edges;
        for (let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {
          const edge = edges[edgeIndex];
          let warmEdge = false;
          if (edge.high === pointIndex) {
            this.warmPoint(edge.low, timestamp);
            warmEdge = true;
          } else if (edge.low === pointIndex) {
            this.warmPoint(edge.high, timestamp);
            warmEdge = true;
          }
          if (warmEdge) {
            this.warmEdge(edgeIndex, timestamp);
          }
        }
        this.warmPoint(pointIndex, timestamp);
      }

      /**
       * @param {number} pointIndex
       * @param {number} timestamp
       */
      warmPoint(pointIndex, timestamp) {
        this.#coolingPoints.set(pointIndex, timestamp);
      }
    }

    window.addEventListener("load", () => {
      let detanglerGame = null;
      /** @type {HTMLCanvasElement} */
      const staticEdges = document.getElementById("static-edges");
      /** @type {HTMLCanvasElement} */
      const dynamicEdges = document.getElementById("dynamic-edges");
      /** @type {HTMLCanvasElement} */
      const staticNodes = document.getElementById("static-nodes");
      /** @type {HTMLCanvasElement} */
      const dynamicNodes = document.getElementById("dynamic-nodes");
      // This bit of silliness is just ... ugh.
      // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#scaling_for_high_resolution_displays
      // I'm sure someone, somewhere, thinks it makes perfect sense.
      // That person is a sociopath.
      /** @type {[HTMLCanvasElement, HTMLCanvasElement, HTMLCanvasElement, HTMLCanvasElement]} */
      const canvases = [staticEdges, dynamicEdges, staticNodes, dynamicNodes];
      /** @type {DOMRect} */
      let bounds;
      /** @type {number} */
      let pixels, effectiveWidth, effectiveHeight;
      canvases.forEach((canvas) => {
        bounds = canvas.getBoundingClientRect();
        pixels = window.devicePixelRatio ?? 1;
        canvas.width = bounds.width * pixels;
        canvas.height = bounds.height * pixels;
        canvas.style.width = `${bounds.width}px`;
        canvas.style.height = `${bounds.height}px`;
        effectiveWidth = canvas.width;
        effectiveHeight = canvas.height;
      });
      console.log(`Sizing: window=${window.innerWidth}x${window.innerHeight}, canvas-bounds:${bounds.width}x${bounds.height}, pixels=${pixels}, canvas-effective=${effectiveWidth}x${effectiveHeight}`);
      const paramsFromHash = () => {
        /**
         * Try to extract out state params from the URL hash.
         * This allows us to send tangle URLs to our friends, and they
         * _should_ see the same puzzle.
         * These will end up producing a hash which looks like:
         * {@code #!c=64/s=1732641021784/d=48/g=0}
         * The parameters are:
         * <li>{@code c} for point count</li>
         * <li>{@code s} for RNG seed</li>
         * <li>{@code d} for size divisor. Defaults to 32.  High values produce smaller circles and edges.</li>
         * <li>{@code g} to disable gradients to speed things up, if set to exactly 0.
         * @type {Record<string,string|number>}
         */
        const params = {};
        if (window.location.hash != null && window.location.hash !== "") {
          try {
            window.location.hash
              .replace(/^#?!?/, "")
              .split("/")
              .map((pair) => pair.split("=").map(decodeURIComponent))
              .filter((pair) => pair.length === 2)
              .forEach(([key, value]) => {
                if (/^\d+$/.test(value)) {
                  params[key] = parseInt(value);
                } else {
                  params[key] = value;
                }
              });
          } catch (_e) {
            // don't care
          }
        }
        return params;
      };
      let pointCount = 8;
      /**
       * @param {number} pc
       * @param {number} seed
       * @param {number} divisor
       * @param {boolean} gradients
       * @returns {string}
       */
      const hashForState = (pc, seed, divisor, gradients) => [
        `#!c=${pc}`,
        `s=${seed}`,
        divisor === 32 ? null : `d=${divisor}`,
        gradients ? null : "g=0"
      ].filter((s) => s != null && s !== "").join("/");
      // We could add some logic here to save your place in LocalStorage ... but meh.
      const startGame = () => {
        const params = paramsFromHash();
        // Seed for the RNG.
        const rngSeed = typeof params.s === "number" ? params.s : Date.now();
        // Starting count of points.
        pointCount = typeof params.c === "number" ? params.c : pointCount;
        const divisor = typeof params.d === "number" ? params.d : 32;
        const gradients = params.g !== 0;
        const wantHash = hashForState(pointCount, rngSeed, divisor, gradients);
        if (window.location.hash !== wantHash) {
          window.history.replaceState({}, "", wantHash);
        }
        console.log(`Creating a tangle with ${pointCount} points.  Random seed: ${rngSeed}  GLHF.`);
        Rand.instance = new Rand(rngSeed);
        detanglerGame?.pauseInput(false);
        detanglerGame = new DetanglerActor(pointCount, divisor, gradients, canvases, () => {
          pointCount += 1;
          const nextHash = hashForState(pointCount, rngSeed, divisor, gradients);
          window.history.replaceState({}, "", nextHash);
          setTimeout(startGame, 250);
        });
      };
      startGame();
      window.addEventListener("hashchange", () => {
        startGame();
      });
      window.addEventListener("resize", () => {
        detanglerGame?.onResize();
      });
    });
  </script>
</head>
<body>
<noscript>This game requires JavaScript. Sorry. I promise, it doesn't do anything untoward.</noscript>
<canvas id="static-edges">
  This game requires the browser's Canvas element and isn't particularly audio-description-friendly.
  Sorry about that.
</canvas>
<canvas id="dynamic-edges"></canvas>
<canvas id="static-nodes"></canvas>
<canvas id="dynamic-nodes"></canvas>
</body>
</html>
